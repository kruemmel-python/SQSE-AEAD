#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
sqse_demo.py
============

GPU-auswählbare Demo für deine SQSE-Implementierung in CC_OpenCL.dll.

Highlights:
- GPU-Index wählbar über CLI: --gpu / -g
- DLL sauber binden (ctypes), exakte Signaturen
- Optionales initialize_gpu(device_index)
- SQSE-Kernel laden (embedded)
- Roundtrip (Encrypt -> Decrypt) mit MAE-Kontrolle
- Modi: quick | sweep
- Python 3.12: match/case, dataclasses(slots), präzise Fehler

Wichtiger Hinweis:
- SQSE arbeitet auf float32 in [0,1). Für Bytes: value/255.0 normalisieren.
"""

from __future__ import annotations

# --- Standardbibliothek
from ctypes import cdll, c_int, c_float, c_char_p, POINTER
from dataclasses import dataclass
from typing import Literal, Optional
import argparse
import sys

# --- Drittanbieter
import numpy as np


# ============================================================================
# 1) Fehlerklasse
# ============================================================================
class SQSEError(Exception):
    """Eindeutige Fehlerklasse für Binding- und Laufzeitfehler in dieser Demo."""


# ============================================================================
# 2) Parameter-Container
# ============================================================================
@dataclass(slots=True)
class SQSEParams:
    chaos_K: float = 1.2     # Chirikov-Standard-Map K
    steps: int = 16          # Iterationsanzahl
    n: int = 1024            # Länge des Testsignals
    seed: int = 42           # RNG-Seed
    gpu_index: int = 0       # wählbarer GPU-Index


# ============================================================================
# 3) Array-Helfer
# ============================================================================
def ensure_f32_c(arr: np.ndarray, name: str) -> np.ndarray:
    """Erzwingt float32 + C-Layout für OpenCL/ctypes und 1D-Form."""
    if arr.dtype != np.float32:
        arr = arr.astype(np.float32, copy=False)
    if not arr.flags["C_CONTIGUOUS"]:
        arr = np.ascontiguousarray(arr)
    if arr.ndim != 1:
        raise SQSEError(f"{name}: 1D-Array erwartet, erhalten: shape={arr.shape}")
    return arr


def as_c_float_ptr(arr: np.ndarray) -> POINTER(c_float):
    """Umwandlung in ctypes-Pointer (nach ensure_f32_c)."""
    return arr.ctypes.data_as(POINTER(c_float))


# ============================================================================
# 4) DLL-Bindings
# ============================================================================
@dataclass(slots=True)
class DLLBindings:
    lib: any
    initialize_gpu: Optional[any] = None
    sqse_load_kernels: any = None
    execute_sqse_encrypt_float: any = None
    execute_sqse_decrypt_float: any = None

    @staticmethod
    def load(path: str = "CC_OpenCL.dll") -> "DLLBindings":
        try:
            lib = cdll.LoadLibrary(path)
        except OSError as e:
            raise SQSEError(f"DLL konnte nicht geladen werden: {e}") from e
        return DLLBindings(lib=lib)

    def bind(self) -> None:
        """Bindet verwendete Symbole mit exakten ctypes-Signaturen."""
        # optional
        if hasattr(self.lib, "initialize_gpu"):
            self.lib.initialize_gpu.argtypes = [c_int]
            self.lib.initialize_gpu.restype = c_int
            self.initialize_gpu = self.lib.initialize_gpu
        else:
            self.initialize_gpu = None

        # Kernel-Loader
        self.lib.sqse_load_kernels.argtypes = [c_char_p]
        self.lib.sqse_load_kernels.restype = c_int
        self.sqse_load_kernels = self.lib.sqse_load_kernels

        # Encrypt
        self.lib.execute_sqse_encrypt_float.argtypes = [
            POINTER(c_float), POINTER(c_float),
            c_int, c_float, c_int,
            POINTER(c_float), POINTER(c_float),
        ]
        self.lib.execute_sqse_encrypt_float.restype = c_int
        self.execute_sqse_encrypt_float = self.lib.execute_sqse_encrypt_float

        # Decrypt
        self.lib.execute_sqse_decrypt_float.argtypes = [
            POINTER(c_float), POINTER(c_float), POINTER(c_float),
            c_int, c_float, c_int,
            POINTER(c_float),
        ]
        self.lib.execute_sqse_decrypt_float.restype = c_int
        self.execute_sqse_decrypt_float = self.lib.execute_sqse_decrypt_float


# ============================================================================
# 5) SQSE-Kernroutinen
# ============================================================================
def sqse_encrypt(bind: DLLBindings,
                 data: np.ndarray,
                 key: np.ndarray,
                 chaos_K: float,
                 steps: int) -> tuple[np.ndarray, np.ndarray]:
    """Forward-Map: gibt (theta_T, p_masked) zurück."""
    data = ensure_f32_c(data, "data")
    key  = ensure_f32_c(key,  "key")
    n = data.size

    theta = np.empty(n, dtype=np.float32)
    pmask = np.empty(n, dtype=np.float32)

    rc = bind.execute_sqse_encrypt_float(
        as_c_float_ptr(data), as_c_float_ptr(key),
        c_int(n), c_float(chaos_K), c_int(steps),
        as_c_float_ptr(theta), as_c_float_ptr(pmask),
    )
    if rc != 0:
        raise SQSEError(f"Encrypt RC={rc}")
    return theta, pmask


def sqse_decrypt(bind: DLLBindings,
                 theta: np.ndarray,
                 p_masked: np.ndarray,
                 key: np.ndarray,
                 chaos_K: float,
                 steps: int) -> np.ndarray:
    """Inverse-Map: rekonstruiert Daten in [0,1)."""
    theta    = ensure_f32_c(theta,    "theta")
    p_masked = ensure_f32_c(p_masked, "p_masked")
    key      = ensure_f32_c(key,      "key")

    if not (theta.size == p_masked.size == key.size):
        raise SQSEError(f"theta/p_masked/key: Größeninkonsistenz "
                        f"({theta.size}/{p_masked.size}/{key.size})")

    n = theta.size
    rec = np.empty(n, dtype=np.float32)

    rc = bind.execute_sqse_decrypt_float(
        as_c_float_ptr(theta), as_c_float_ptr(p_masked), as_c_float_ptr(key),
        c_int(n), c_float(chaos_K), c_int(steps),
        as_c_float_ptr(rec),
    )
    if rc != 0:
        raise SQSEError(f"Decrypt RC={rc}")
    return rec


def sqse_roundtrip(bind: DLLBindings,
                   data: np.ndarray,
                   key: np.ndarray,
                   chaos_K: float,
                   steps: int) -> tuple[np.ndarray, np.ndarray, float]:
    """Encrypt -> Decrypt; gibt (recon, theta_T, MAE) zurück."""
    theta, pmask = sqse_encrypt(bind, data, key, chaos_K, steps)
    recon = sqse_decrypt(bind, theta, pmask, key, chaos_K, steps)
    mae = float(np.mean(np.abs(recon - data)))
    return recon, theta, mae


# ============================================================================
# 6) Demo-Runner mit GPU-Auswahl
# ============================================================================
def run_demo(mode: Literal["quick", "sweep"],
             params: SQSEParams,
             dll_path: str) -> None:
    """Führt je nach Modus die Demo aus – mit frei wählbarem GPU-Index."""
    # DLL laden/binden
    bind = DLLBindings.load(dll_path)
    bind.bind()

    # GPU-Initialisierung (mit Device-Index)
    if bind.initialize_gpu is not None:
        rc = bind.initialize_gpu(c_int(params.gpu_index))
        if rc != 0:
            raise SQSEError(f"initialize_gpu(gpu_index={params.gpu_index}) RC={rc}")
        print(f"[info] GPU initialisiert mit Index {params.gpu_index}")
    else:
        print("[warn] DLL exportiert kein initialize_gpu(int); fahre ohne explizite Auswahl fort.")

    # Kernel laden (embedded Source)
    rc = bind.sqse_load_kernels(b"embedded")
    if rc != 0:
        raise SQSEError(f"sqse_load_kernels RC={rc}")

    # Demodaten (float32 in [0,1))
    rng = np.random.default_rng(params.seed)
    data = rng.random(params.n, dtype=np.float32)
    key  = rng.random(params.n, dtype=np.float32)

    # Modus steuern
    match mode:
        case "quick":
            recon, theta, mae = sqse_roundtrip(bind, data, key, params.chaos_K, params.steps)
            print(f"[quick] GPU={params.gpu_index}  N={params.n}  "
                  f"K={params.chaos_K:.3f}  steps={params.steps}  ->  MAE={mae:.6e}")

        case "sweep":
            Ks = (0.8, 1.2, 2.0, 4.0)
            Steps = (8, 16, 32, 64)
            print(f"[sweep] GPU={params.gpu_index}  N={params.n}")
            for K in Ks:
                for s in Steps:
                    _, _, mae = sqse_roundtrip(bind, data, key, K, s)
                    print(f"  K={K:3.1f}  steps={s:2d}  ->  MAE={mae:.6e}")

        case _:
            raise SQSEError(f"Unbekannter Modus: {mode!r}")


# ============================================================================
# 7) CLI-Parser
# ============================================================================
def parse_args(argv: list[str]) -> tuple[Literal["quick", "sweep"], SQSEParams, str]:
    """
    CLI:
      --mode | -m : quick | sweep
      --dll  | -d : Pfad zur DLL
      --n         : Länge
      --K         : chaos_K
      --steps     : Iterationen
      --seed      : RNG-Seed
      --gpu | -g  : GPU-Index (int)
    """
    p = argparse.ArgumentParser(
        prog="sqse_demo",
        description="SQSE-Demo (quantum-inspired, chaos-basierte Verschlüsselung) "
                    "gegen CC_OpenCL.dll – mit GPU-Auswahl."
    )
    p.add_argument("-m", "--mode", choices=["quick", "sweep"], default="quick",
                   help="Demo-Modus: 'quick' für Einzeltest, 'sweep' für K/steps-Gitterlauf.")
    p.add_argument("-d", "--dll", default="CC_OpenCL.dll",
                   help="Pfad zur CC_OpenCL.dll (kompilierte Bibliothek)")
    p.add_argument("--n", type=int, default=1024, help="Länge der Testdaten")
    p.add_argument("--K", type=float, default=1.2, help="chaos_K (Chirikov-Map)")
    p.add_argument("--steps", type=int, default=16, help="Iterationsanzahl")
    p.add_argument("--seed", type=int, default=42, help="RNG-Seed")
    p.add_argument("-g", "--gpu", type=int, default=0,
                   help="GPU-Index für initialize_gpu(int) (Default: 0)")

    args = p.parse_args(argv)
    params = SQSEParams(
        chaos_K=float(args.K),
        steps=int(args.steps),
        n=int(args.n),
        seed=int(args.seed),
        gpu_index=int(args.gpu),
    )
    return args.mode, params, args.dll


# ============================================================================
# 8) Entrypoint
# ============================================================================
def main() -> None:
    mode, params, dll_path = parse_args(sys.argv[1:])
    run_demo(mode, params, dll_path)


if __name__ == "__main__":
    main()
